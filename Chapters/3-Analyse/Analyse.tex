%=========================================
% 	   Analyse     		 =
%=========================================
\chapter{Analyse}
\label{ch:analyse}

\section{Differenzierung}

Dieses Kapitel vergleicht die Prinzipien, Eigenschaften und Umsetzungskriterien der Cloud-Native-Architektur mit denen anderer Architekturen und stellt deren Unterschiede dar.

\subsection{Monolithen}

Ein grundlegender Unterschied zwischen einer monolitischen Softwarearchitektur und der einer Cloud-Native-Architektur findet sich in der Zusammensetzung ihrer Komponenten. Ein sogenannter \textit{Monolith} ist ein einheitliches Softwaresystem, welches die gesamte Programmlogik, Datenverwaltung und die Benutzeroberfläche in einer abgeschlossenen, ausführbaren Datei verbindet. Die in ihr enthaltenen Komponenten sind oft eng miteinander verknüpft. Diese Zusammensetzung bietet einen in den Anfangsphasen der Entwicklung simplen Implemtierungsprozess, da die Entwickler während der Umsetzung eines Prototyps unmittelbar Änderungen an den verschiedenen Komponenten umsetzen können. In den Anfängen eines Projektes ist es zudem simpel, Änderung zu veröffentlichen. Dazu muss lediglich eine neue Version der gebündelten Datei des Monoliths an seine Nutzer verteilt werden.

Ein zunehmendes Wachstum des Monoliths fördert jedoch eventuell einige, nicht unerhebliche Nachteile. Erhöht sich die Größe des Monoliths und seiner Codebasis, wächst die Wahrscheinlichkeit von abnehmender modularität seiner Bestandteile. Wenn sie stark miteinander verwoben sind, steigt die Komplexität bei notwendigen Veränderungen oder der Einführung neuer Funktionen an. Gleichzeitig wächst die Einarbeitungszeit in das Projekt für neue Teammitglieder. Es besteht weiterhin die Möglichkeit, dass sich der Softwaremonolith in einen ''Big Ball of Mud'' verwandelt. ''Ein Big Ball of Mud ist ein planlos strukturierter, ausufernder, schlampiger, mit Klebeband und Bindedraht zusammengehaltener Spaghetti-Code-Dschungel [todo: CITE].'' Mit zunehmender Seniorität der Mitglieder des Entwicklungsteams besteht außerdem die Gefahr, dass nur wenige oder gar keine Entwickler die gesamte Funktion des Monolithen vollständig nachvollziehen können. Schlussendlich ist man in der Entwicklung eines Monoliths meist unabdinglich an seine ursprünglich ausgewählte Technologieplatform gebunden. Der dichte Verbund der Komponenten des Monoliths erschwert den Austausch einzelner Technologien erheblich. \\

Der Aufbau eines Cloud-Native-Softwareprojektes steht im direkten Gegensatz zur monolitischen Softwarearchitektur. Es besteht aus individuellen, lose gekoppelten Kleinstbausteinen. Ihre Berührungspunkte untereinander bestehen einzig und allein aus ihren nach außen hin verfügbaren Schnittstellen. Aufgrund dieser Tatsache ist die Modurarität und Abgeschlossenheit der Bestandteile dauerhaft gewährleistet. Weiterhin ermöglicht die Kapselung der verschiedenen Micro-Services eine programmiersprachenagnostische Entwicklung und somit die Auswahl des ''Best Tool For The Job''. \\ 
Die Komplexität der Bestandteile eines Cloud-Native-Softwaresystems besteht im Gegensatz zu denen eines Monolithen nur aus der Komplexität der einzelnen Micro-Services. Da die Schnittstellen der verschiedenen Micro-Services fest definiert sind, kann bei der Betrachtung eines einzelnen Micro-Services die interne Funktionsweise seiner Interaktionspartner gänzlich außer Acht gelassen werden. Im Idealfall wird ein Micro-Service außerdem von genau einer festen Gruppe oder eines festen Teams von Entwickler verwaltet. Deren Mitglieder benötigen dann nur das Wissen über die Funktionalität des von ihnen betreuten Bestandteils der gesamten Architektur. Diese Tatsachen erleichtern den Entwicklungsprozess bei Fehlerbehebungen, der Erweiterung eines Micro-Service um zusätzliche Funktionen und das Testen der unterschiedlichen Micro-Services als abgeschlossene Einheit. Im konkreten Testprozess eines einzelnen Micro-Service kann die Funktion anderer, zum Funktionsaufruf benötigter Micro-Services durch den Programmierer simuliert werden. Diese Aufteilung hat jedoch den Nachteil, dass die Komplexität des Gesamtsystems direkt im Zusammenhang zur Anzahl und Qualität der Dokumentation seiner Einzelteile steht. Je größer die Anzahl unterschliedlicher Micro-Services, desto schwieriger ist es für die Beauftragten des Softwaresystemes, einen Überblick zu behalten. Bei sehr großen Systemen steigt die Gefahr von Quelltextduplizierung und vermindeter Auffindbarkeit bereits existierender Micro-Services, die eine benötigte Funktionsweise bereits abdecken. \\
Solange sich die Schnittstellen der Micro-Services nicht ändern, kann die Weiterentwicklung unabhängig von anderen Implementierungsteams geschehen. Strategien zur Anpassung des Gesamtsystems nach der Veränderung einer Schnittstelle finden sich in Kapitel \ref{grundlagen:microcomms}. Diese im vorangegangenen Absatz genannten Punkte lassen sich unter den Begriffen \textit{Agilität} und \textit{Continous Innovation} zusammenfassen. \\ 
Im Kontrast zur monolitischen Softwarearchitektur ermöglicht der Aufbau der Micro-Service-Architektur und die Bereitstellung von Micro-Services auf Cloud-Hostern einen dynamischen Austausch ihrer Bestandteile zum Zeitpunkt der Veröffentlichung neuer Versionen. Damit muss ein Benutzer des Softwaresystems bei Änderung seiner Komponenten nur selten in Kenntnis gesetzt werden. Dieser Prozess ermöglicht die Minimierung von Fragmentierungen zwischen den unterschiedlichen, aktiv genutzten Versionen eines Softwaresystems, da es weitestgehend automatisiert aktualisiert werden kann. Dieser Prozess wird mit dem Begriff \textit{Continous Delivery} bezeichnet. \\

Die Cloud-Native-Architektur unterscheidet sich von einer monolitischen weiterhin durch den Prozess der Skalierung. Der traditionelle Skalierungsansatz eines Monolitihen ist die parallele Ausführung mehrerer Instanzen und die subsequente Verteilung von Anfragen über einen ''Load-Balancer''. Da der Monolith jedoch ein festes Bündel seiner Bestandteile ist, ist es nur möglich, ihn als Ganzes zu skalieren. Die Aufteilung der Micro-Services der Cloud-Native-Architektur erlaubt es hingegen, jeder Komponente genau nur die benötigten Ressourcen zuzuweisen. [TODO: Caching?] Dieses Vorgehen erlaubt eine dynamische Umverteilung von bereits vorhandener Ressourcen und eine Zuweisung gänzlich neuer Rechen- und Speicherleistung bei veränderter Lastverteilung oder einer Welle von neuen Anfragen. Im Ideallfall werden solche Skalierungsprozesse vom verwendeten Cloud-Hoster vollautomatisiert umgesetzt. Ihre dynamische Natur erlaubt weiterhin flexible Bezahlungsmodelle. Im sogenannten ''Pay-As-You-Go''-Modell bezahlt ein Nutzer eines Cloud-Hosters nur genau die Ressourcen, die zur Ausführung seiner Software genutzt werden. Die Zustandslosigkeit der Bestandteile einer Cloud-Native-Architektur erlaubt eine Fokussierung auf die verwendeten \textit{Datastores} bei der Umsetzung effizienter Caching-Strategien. 


- Verfügbarkeit
 - Single Point of Failure

\section{Zusammenfassung}